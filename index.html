<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Survivor Z - Expert Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; touch-action: none; user-select: none; }
        canvas { display: block; background-color: #2c3e50; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #timer { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            font-size: 28px; font-weight: bold; background: rgba(0,0,0,0.8); 
            padding: 5px 25px; border-radius: 20px; border: 2px solid #555;
        }
        .flame-timer { color: #ff4757 !important; border-color: #ff4757 !important; text-shadow: 0 0 15px #ff4757; animation: shake 0.1s infinite; }
        @keyframes shake { 0%{margin-left:-2px} 100%{margin-left:2px} }

        #level-info { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 8px; pointer-events: auto; }
        #lvl { font-size: 24px; font-weight: bold; color: #eccc68; text-shadow: 1px 1px 2px black; }
        
        .inventory { display: flex; gap: 6px; }
        .slot { 
            width: 42px; height: 42px; background: rgba(0,0,0,0.6); 
            border: 2px solid #444; border-radius: 8px; position: relative;
            cursor: help; display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 14px;
        }
        .slot.weapon { border-color: #ff4757; }
        .slot.passive { border-color: #2ed573; }

        #tooltip { 
            position: absolute; background: rgba(0,0,0,0.95); border: 1px solid #ffa502; 
            padding: 12px; border-radius: 8px; font-size: 13px; display: none; 
            z-index: 200; width: 200px; pointer-events: none; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .hud-bars { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 85%; max-width: 500px; }
        .bar { height: 12px; background: #111; border-radius: 6px; overflow: hidden; border: 1px solid #444; margin-top: 5px; }
        #hp-fill { background: linear-gradient(90deg, #ff4757, #ff6b81); width: 100%; height: 100%; transition: width 0.2s; }
        #xp-fill { background: linear-gradient(90deg, #2ed573, #7bed9f); width: 0%; height: 100%; transition: width 0.2s; }
        
        #modal, #start { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 100; }
        .cards { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; padding: 20px; }
        .card { background: #2f3542; border: 3px solid #57606f; border-radius: 15px; padding: 15px; width: 170px; text-align: center; cursor: pointer; transition: 0.2s; }
        .card:hover { border-color: #ffa502; transform: scale(1.05); background: #3e4451; }
        .btn-start { padding: 18px 50px; border-radius: 40px; border: none; background: #ff4757; color: white; font-size: 20px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 0 #b33939; }
        .btn-start:active { transform: translateY(2px); box-shadow: 0 2px 0 #b33939; }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    <div id="tooltip"></div>

    <div id="ui">
        <div id="timer">10:00</div>
        
        <div id="level-info">
            <div id="lvl">NIVEAU 1</div>
            <div class="inventory" id="weapon-slots">
                <div class="slot weapon" onmouseover="showTip(event, 'w0')" onmouseout="hideTip()"></div>
                <div class="slot weapon" onmouseover="showTip(event, 'w1')" onmouseout="hideTip()"></div>
                <div class="slot weapon" onmouseover="showTip(event, 'w2')" onmouseout="hideTip()"></div>
                <div class="slot weapon" onmouseover="showTip(event, 'w3')" onmouseout="hideTip()"></div>
            </div>
            <div class="inventory" id="passive-slots">
                <div class="slot passive" onmouseover="showTip(event, 'p0')" onmouseout="hideTip()"></div>
                <div class="slot passive" onmouseover="showTip(event, 'p1')" onmouseout="hideTip()"></div>
                <div class="slot passive" onmouseover="showTip(event, 'p2')" onmouseout="hideTip()"></div>
                <div class="slot passive" onmouseover="showTip(event, 'p3')" onmouseout="hideTip()"></div>
            </div>
        </div>

        <div class="hud-bars">
            <div class="bar"><div id="hp-fill"></div></div>
            <div class="bar"><div id="xp-fill"></div></div>
        </div>
    </div>

    <div id="modal">
        <h2 style="color:white; letter-spacing: 2px;">AMÉLIORATION DISPONIBLE</h2>
        <div class="cards" id="choices"></div>
    </div>

    <div id="start" style="display:flex">
        <h1 style="color:#ff4757; font-size: 50px; margin-bottom: 10px;">SURVIVOR Z</h1>
        <p style="color: #a4b0be; margin-bottom: 30px;">Z,Q,S,D pour bouger | Survis aux 10 minutes</p>
        <button class="btn-start" onclick="initGame()">COMMENCER LA CHASSE</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W = window.innerWidth, H = window.innerHeight;
        canvas.width = W; canvas.height = H;

        let player, enemies, gems, bullets, particles, strikes;
        let gameActive = false, startTime, elapsedTime = 0, lastSpawn = 0;
        const keys = { z:false, s:false, q:false, d:false };

        const WEAPONS_DATA = {
            kunai: { t: 'KUNAI', d: 'Tir auto rapide', col: '#f1c40f', sym: 'K' },
            guardian: { t: 'GUARDIAN', d: 'Lames circulaires', col: '#ced6e0', sym: 'G' },
            thunder: { t: 'FOUDRE', d: 'Dégâts de zone aléatoires', col: '#48dbfb', sym: 'F' },
            boomerang: { t: 'BOOMERANG', d: 'Traverse et revient', col: '#54a0ff', sym: 'B' },
            saw: { t: 'SCIE', d: 'Dégâts de zone proches', col: '#95afc0', sym: 'S' }
        };

        const PASSIVES_DATA = {
            force: { t: 'FORCE', d: '+20% de puissance', col: '#ff4757', sym: 'Atk' },
            vitesse: { t: 'VITESSE', d: '+15% move speed', col: '#ffa502', sym: 'Spd' },
            portee: { t: 'ZONE', d: '+20% taille d\'effet', col: '#70a1ff', sym: 'Zon' },
            recharge: { t: 'RECHARGE', d: '-15% temps de recharge', col: '#eccc68', sym: 'Cdr' },
            quantite: { t: 'QUANTITÉ', d: '+1 projectile par tir', col: '#2ed573', sym: 'Qte' },
            sagesse: { t: 'SAGESSE', d: '+15% XP par gemme', col: '#d2dae2', sym: 'Xp' }
        };

        class Player {
            constructor() {
                this.x = W/2; this.y = H/2; this.hp = 100; this.maxHp = 100;
                this.xp = 0; this.xpReq = 50; this.lvl = 1; this.speed = 3.5;
                this.weapons = { kunai: 1 };
                this.passives = {};
                this.timers = { kunai: 0, thunder: 0, boomerang: 0, saw: 0 };
                this.rot = 0;
            }
            getStat(type) {
                let v = this.passives[type] || 0;
                if(type === 'force') return 1 + (v * 0.2);
                if(type === 'recharge') return 1 - (v * 0.15);
                if(type === 'quantite') return v;
                if(type === 'portee') return 1 + (v * 0.2);
                if(type === 'sagesse') return 1 + (v * 0.15); // Equilibré à 15%
                return 1;
            }
            update() {
                let mx = 0, my = 0;
                if(keys.z) my -= 1; if(keys.s) my += 1;
                if(keys.q) mx -= 1; if(keys.d) mx += 1;
                let ms = this.speed * (1 + (this.passives.vitesse || 0) * 0.15);
                if(mx !== 0 || my !== 0) {
                    let d = Math.sqrt(mx*mx+my*my);
                    this.x += (mx/d)*ms; this.y += (my/d)*ms;
                }
                this.x = Math.max(20, Math.min(W-20, this.x));
                this.y = Math.max(20, Math.min(H-20, this.y));
                this.rot += 0.08;
                this.fire();
            }
            fire() {
                let now = Date.now();
                let cd = this.getStat('recharge');
                let qte = this.getStat('quantite');
                let dmg = this.getStat('force');
                let sz = this.getStat('portee');

                if(now - this.timers.kunai > (800 - (this.weapons.kunai*40)) * cd) {
                    for(let i=0; i<1+qte; i++) {
                        let t = getNearestEnemy(this.x, this.y, 500);
                        if(t) bullets.push(new Projectile(this.x, this.y, Math.atan2(t.y-this.y, t.x-this.x)+(i*0.1), 10, 20*dmg, "#f1c40f", 5*sz));
                    }
                    this.timers.kunai = now;
                }
                if(this.weapons.thunder && now - this.timers.thunder > 2200 * cd) {
                    for(let i=0; i<this.weapons.thunder+qte; i++) {
                        let t = getRandomEnemyNearby(this.x, this.y, 400);
                        if(t) { strikes.push(new Lightning(t.x, t.y)); t.takeDamage(30 * dmg); }
                    }
                    this.timers.thunder = now;
                }
                if(this.weapons.boomerang && now - this.timers.boomerang > 2500 * cd) {
                    for(let i=0; i<1+qte; i++) bullets.push(new Boomerang(this.x, this.y, (Math.PI*2/(1+qte))*i, sz, dmg));
                    this.timers.boomerang = now;
                }
            }
            draw() {
                let sz = this.getStat('portee'), dmg = this.getStat('force');
                if(this.weapons.guardian) {
                    let c = this.weapons.guardian + 1 + this.getStat('quantite');
                    for(let i=0; i<c; i++) {
                        let a = this.rot + (i*Math.PI*2/c);
                        let lx = this.x + Math.cos(a)*100; let ly = this.y + Math.sin(a)*100;
                        ctx.fillStyle = "#ced6e0"; ctx.beginPath(); ctx.arc(lx, ly, 12*sz, 0, Math.PI*2); ctx.fill();
                        enemies.forEach(e => { if(Math.hypot(e.x-lx, e.y-ly) < 25*sz) e.takeDamage(4*dmg); });
                    }
                }
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = "#2ed573"; ctx.fillRect(-10, -10, 20, 25);
                ctx.fillStyle = "#ffdbac"; ctx.beginPath(); ctx.arc(0, -15, 12, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(-4, -15, 2, 0, Math.PI*2); ctx.fill(); ctx.arc(4, -15, 2, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Enemy {
            constructor(wave) {
                let side = Math.floor(Math.random()*4);
                if(side==0){this.x=Math.random()*W; this.y=-30} else if(side==1){this.x=W+30; this.y=Math.random()*H}
                else if(side==2){this.x=Math.random()*W; this.y=H+30} else {this.x=-30; this.y=Math.random()*H}
                this.hp = 20 + (wave * 45); this.speed = 1.3 + (wave * 0.4); this.r = 16;
                this.hit = 0; this.color = ["#7bed9f", "#eccc68", "#ffa502", "#ff4757", "#57606f"][Math.min(wave, 4)];
            }
            takeDamage(amt) {
                this.hp -= amt; this.hit = 5;
                if(this.hp <= 0) {
                    for(let i=0; i<6; i++) particles.push(new Particle(this.x, this.y, this.color));
                    gems.push(new Gem(this.x, this.y));
                }
            }
            update() {
                let a = Math.atan2(player.y-this.y, player.x-this.x);
                this.x += Math.cos(a)*this.speed; this.y += Math.sin(a)*this.speed;
                if(this.hit > 0) this.hit--;
                if(Math.hypot(this.x-player.x, this.y-player.y) < 25) player.hp -= 0.6;
            }
            draw() {
                ctx.fillStyle = this.hit > 0 ? "white" : this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = "black"; ctx.stroke();
            }
        }

        class Boomerang {
            constructor(x, y, ang, szM, dmgM) {
                this.x=x; this.y=y; this.ang=ang; this.dist=0; this.ret=false; this.act=true; this.r=0; this.dmg=18*dmgM; this.sz=18*szM;
            }
            update() {
                this.r += 0.4;
                if(!this.ret) {
                    this.x += Math.cos(this.ang)*8; this.y += Math.sin(this.ang)*8;
                    this.dist += 8; if(this.dist > 350) this.ret = true;
                } else {
                    let a = Math.atan2(player.y-this.y, player.x-this.x);
                    this.x += Math.cos(a)*10; this.y += Math.sin(a)*10;
                    if(Math.hypot(this.x-player.x, this.y-player.y) < 20) this.act = false;
                }
                enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < e.r + this.sz) e.takeDamage(this.dmg); });
            }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.r);
                ctx.fillStyle="#54a0ff"; ctx.beginPath(); ctx.moveTo(0,-this.sz); ctx.lineTo(this.sz,this.sz); ctx.lineTo(-this.sz,this.sz); ctx.fill();
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x,y,a,s,d,c,r) { this.x=x; this.y=y; this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.dmg=d; this.col=c; this.r=r; this.act=true; }
            update() { 
                this.x+=this.vx; this.y+=this.vy; 
                if(this.x<0||this.x>W||this.y<0||this.y>H) this.act=false; 
                enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y) < e.r+this.r){ e.takeDamage(this.dmg); this.act=false; }}); 
            }
            draw() { ctx.fillStyle=this.col; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill(); }
        }

        class Lightning { constructor(x,y) { this.x=x; this.y=y; this.life=10; } draw() { ctx.strokeStyle="white"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(this.x,-50); ctx.lineTo(this.x+20,this.y/2); ctx.lineTo(this.x,this.y); ctx.stroke(); this.life--; } }
        class Particle { constructor(x,y,c) { this.x=x; this.y=y; this.c=c; this.l=15; this.vx=(Math.random()-0.5)*6; this.vy=(Math.random()-0.5)*6; } draw() { ctx.fillStyle=this.c; ctx.globalAlpha=this.l/15; ctx.fillRect(this.x,this.y,4,4); ctx.globalAlpha=1; this.x+=this.vx; this.y+=this.vy; this.l--; } }
        class Gem { constructor(x,y) { this.x=x; this.y=y; } update() { let d=Math.hypot(this.x-player.x, this.y-player.y); if(d<150) { let a=Math.atan2(player.y-this.y, player.x-this.x); this.x+=Math.cos(a)*12; this.y+=Math.sin(a)*12; } if(d<20) { player.xp += 20 * player.getStat('sagesse'); updateUI(); return true; } return false; } draw() { ctx.fillStyle="#7bed9f"; ctx.fillRect(this.x-4,this.y-4,8,8); } }

        function getNearestEnemy(x,y,max) { let n=null, m=max; enemies.forEach(e=>{let d=Math.hypot(e.x-x,e.y-y); if(d<m){m=d;n=e;}}); return n; }
        function getRandomEnemyNearby(x,y,r) { let t=enemies.filter(e=>Math.hypot(e.x-x,e.y-y)<r); return t[Math.floor(Math.random()*t.length)]; }

        function showTip(e, id) {
            let tip = document.getElementById('tooltip');
            let type = id.startsWith('w') ? 'weapon' : 'passive';
            let slotIdx = parseInt(id[1]);
            let currentItems = type === 'weapon' ? Object.keys(player.weapons) : Object.keys(player.passives);
            let key = currentItems[slotIdx];
            
            if(key) {
                let data = type === 'weapon' ? WEAPONS_DATA[key] : PASSIVES_DATA[key];
                let lvl = type === 'weapon' ? player.weapons[key] : player.passives[key];
                tip.innerHTML = `<strong style="color:${data.col}">${data.t}</strong> (Niv. ${lvl})<br><br><span style="color:#ddd">${data.d}</span>`;
                tip.style.display = 'block';
                tip.style.left = (e.pageX + 15) + 'px';
                tip.style.top = (e.pageY + 15) + 'px';
            }
        }
        function hideTip() { document.getElementById('tooltip').style.display = 'none'; }

        function updateUI() {
            document.getElementById('hp-fill').style.width = (player.hp/player.maxHp)*100 + "%";
            document.getElementById('xp-fill').style.width = (player.xp/player.xpReq)*100 + "%";
            document.getElementById('lvl').innerText = "NIVEAU " + player.lvl;
            
            const wKeys = Object.keys(player.weapons);
            const pKeys = Object.keys(player.passives);
            for(let i=0; i<4; i++) {
                let ws = document.getElementById('weapon-slots').children[i];
                if(wKeys[i]) { ws.innerText = WEAPONS_DATA[wKeys[i]].sym; ws.style.background = WEAPONS_DATA[wKeys[i]].col; ws.style.color = "#000"; }
                let ps = document.getElementById('passive-slots').children[i];
                if(pKeys[i]) { ps.innerText = PASSIVES_DATA[pKeys[i]].sym; ps.style.background = PASSIVES_DATA[pKeys[i]].col; ps.style.color = "#000"; }
            }

            if(player.xp >= player.xpReq) levelUp();
            if(player.hp <= 0) { gameActive = false; alert("FIN DE LA SURVIE !"); location.reload(); }
        }

        function levelUp() {
            player.lvl++; player.xp = 0; player.xpReq += 50; gameActive = false;
            let pool = [];
            Object.keys(WEAPONS_DATA).forEach(k => { if(player.weapons[k] || Object.keys(player.weapons).length < 4) pool.push({id:k, ...WEAPONS_DATA[k], type:'weapon'}); });
            Object.keys(PASSIVES_DATA).forEach(k => { if(player.passives[k] || Object.keys(player.passives).length < 4) pool.push({id:k, ...PASSIVES_DATA[k], type:'passive'}); });

            let html = "", choices = [];
            while(choices.length < 3 && pool.length > 0) choices.push(pool.splice(Math.floor(Math.random()*pool.length), 1)[0]);

            choices.forEach(s => {
                let curLvl = (s.type === 'weapon' ? player.weapons[s.id] : player.passives[s.id]) || 0;
                html += `<div class="card" onclick="upgrade('${s.id}', '${s.type}')"><b style="color:${s.col}">${s.t}</b><br><small>Niveau ${curLvl+1}</small><br><br><span style="font-size:11px">${s.d}</span></div>`;
            });
            document.getElementById('choices').innerHTML = html;
            document.getElementById('modal').style.display = "flex";
        }

        function upgrade(id, type) {
            if(type === 'weapon') player.weapons[id] = (player.weapons[id] || 0) + 1;
            else player.passives[id] = (player.passives[id] || 0) + 1;
            document.getElementById('modal').style.display = "none";
            gameActive = true; updateUI(); loop();
        }

        function initGame() {
            player = new Player(); enemies = []; gems = []; bullets = []; strikes = []; particles = [];
            gameActive = true; startTime = Date.now();
            document.getElementById('start').style.display = "none";
            updateUI(); loop();
        }

        function loop() {
            if(!gameActive) return;
            ctx.clearRect(0, 0, W, H);
            elapsedTime = (Date.now() - startTime) / 1000;
            
            let rem = 600 - elapsedTime;
            let timerEl = document.getElementById('timer');
            if(rem > 0) {
                timerEl.innerText = Math.floor(rem/60).toString().padStart(2,'0') + ":" + Math.floor(rem%60).toString().padStart(2,'0');
            } else {
                timerEl.innerText = "+" + Math.floor(Math.abs(rem)/60).toString().padStart(2,'0') + ":" + Math.floor(Math.abs(rem)%60).toString().padStart(2,'0');
                timerEl.classList.add('flame-timer');
            }

            let wave = Math.floor(elapsedTime / 120);
            let spawnRate = Math.max(80, 850 - (wave * 150));
            if(rem <= 0) spawnRate /= 2; // SPAWN DOUBLE après 10 min

            if(Date.now() - lastSpawn > spawnRate) { enemies.push(new Enemy(wave)); lastSpawn = Date.now(); }

            player.update(); player.draw();
            enemies = enemies.filter(e => { e.update(); e.draw(); return e.hp > 0; });
            bullets = bullets.filter(b => { b.update(); b.draw(); return b.act; });
            gems = gems.filter(g => !g.update()); gems.forEach(g => g.draw());
            strikes = strikes.filter(s => { s.draw(); return s.life > 0; });
            particles = particles.filter(p => { p.draw(); return p.l > 0; });
            requestAnimationFrame(loop);
        }

        window.onkeydown = e => keys[e.key.toLowerCase()] = true;
        window.onkeyup = e => keys[e.key.toLowerCase()] = false;
        window.onresize = () => { W=window.innerWidth; H=window.innerHeight; canvas.width=W; canvas.height=H; };
    </script>
</body>
</html>
